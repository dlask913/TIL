## (sql) MySQL 인덱스 활용
> DB 성능 최적화, 인덱스 활용 (주의사항, Multi-Column Index)

<br>

## DB 성능 최적화
- 동시 사용자 수 증가, 데이터 양 증가, 비효율적인 SQL 문 사용으로 DB 성능 저하가 발생한다.
- 시스템 변경 없이 근본적인 문제 해결을 위해 SQL 튜닝을 우선적으로 고려한다.

### 동작
> Client → MySQL 엔진 → 스토리지 엔진 → MySQL 엔진 → Client

![image](https://github.com/user-attachments/assets/58febbf4-ab2e-4a0d-99f3-6a20a0b89bf6)

- Optimizer 는 SQL문을 분석하여 효율적으로 데이터를 가져올 수 있는 계획을 세우며, 잘못된 설계로 인해 예상과 다른 계획이 수립될 수 있다.
- 대부분 스토리지 엔진으로부터 데이터를 가져올 때 성능 저하가 발생한다.
- MySQL 엔진은 가져온 데이터를 정렬 및 필터링하여 클라이언트로 전달한다.
- 스토리지 엔진에서 **데이터를 찾기 쉽게 바꾸고 가져오는 데이터의 양을 줄여** 성능을 향상시킨다. → 인덱스 활용

<br>

## 인덱스 활용
- 인덱스를 사용하면 데이터를 빨리 찾기 위해 특정 컬럼을 기준으로 미리 정렬해둔 표가 생성된다. ( B-Tree 구조 )
- 예를 들어, 나이로 인덱스를 생성하고 23~24살을 조회하면 23살로 시작되는 지점과 24살로 시작되는 지점 사이 데이터를 가져오기 때문에 모든 데이터를 일일이 찾지 않아 효율적이다. 
- PK 는 원본 데이터 자체가 정렬되는 클러스터링 인덱스로 동작한다.
- PK 는 인덱스가 기본적으로 적용되기 때문에 PK 를 기준으로 데이터가 정렬된다.
- MySQL 의 경우, UNIQUE 제약 조건을 추가하면 자동으로 인덱스가 생성되어 조회 성능이 향상된다.
- 항상 인덱스 생성 전후 소요 시간을 비교하여 개선된 정도를 확인한다. (★)
- 인덱스 생성
```sql
CREATE INDEX <IDX-NAME> ON <TB-NAME>
```
- 인덱스 조회
```SQL
SHOW INDEX FROM <TB-NAME>
```
- UNIQE 제약 조건
```sql
CREATE TABLE <TB-NAME> (
	..
	NAME VARCHAR(100) UNIQUE
);
```

<br>

### 주의 사항
- 인덱스를 많이 생성되면 조회 성능은 향상되지만 인덱스용 테이블이 추가적으로 생성되기 때문에 **쓰기 작업 성능이 저하**된다. 
- 인덱스가 많을수록 쓰기 작업(생성,수정,삭제) 을 해야 하는 테이블이 늘어난다. 

<br>

### Multi-Column Index 
- 2 개 이상의 컬럼을 묶어서 생성하는 인덱스를 말한다. 
- A, B 에 대한 컬럼을 묶었을 때, 앞에 기재한 A 를 기준으로 먼저 정렬되기 때문에 A 의 인덱스를 활용하듯 사용할 수 있다. 
- 예를 들어, 팀, 직급, 이름이라는 컬럼을 가지고 있을 때 이름을 조회하는 경우가 더 많기 때문에 **소분류 → 중분류 → 대분류** 순으로 나열하여 인덱스를 생성하는 게 유리할 수 있다. 
- 멀티 컬럼 인덱스 생성
```sql
CREATE INDEX <IDX-NAME> ON <TB-NAME>(COLUMN1, COLUMN2, ..)
```

<br>

## 참고
[비전공자도 이해할 수 있는 MySQL 성능 최적화 입문/실전 (SQL 튜닝편)](https://inf.run/DzjSq)