## (sql) 인덱스 
> 실행 순서, 종류, 사용 방법, 사용되는 상황, 트리 자료 구조

<br>

## 인덱스
- 지정된 컬럼과 해당 값을 가진 실제 데이터 행(ex> PK)의 위치를 한 쌍으로 저장한다
- 인덱스 내부 데이터는 항상 정렬된 상태를 유지한다

### 실행 순서
> items 테이블의 item_name 에 걸린 인덱스가 있을 때, where 절로 item_name 조건이 있는 경우

1. items 테이블을 스캔하는 대신 item_name 기반 인덱스를 찾아간다
2. 인덱스는 정렬되어 있으므로 빠르게 조회
3. 실제 위치 확인
4. 해당 실제 위치로 점프해서 데이터 조회

<br>

### 종류
#### 1. 클러스터 인덱스
- 기본키를 기반으로 만드는 인덱스
- 원본 데이터 자체를 인덱스에 함께 보관해서 원본 데이터를 매우 빠르게 찾을 수 있다
#### 2. 보조 인덱스
- 원본데이터의 기본키 값을 함께 보관
- 이 기본키 값으로 클러스터 인덱스를 통해 원하는 데이터 조회

<br>

### 사용방법
#### 인덱스 생성
- `idx_테이블명_컬럼명`과 같은 규칙으로 지으면 관리하기 편하다.
```mysql
CREATE INDEX 인덱스이름 ON 테이블이름 (컬럼1, 컬럼2, ...);
```

#### 테이블의 인덱스 정보 확인

<img width="1071" height="116" alt="image" src="https://github.com/user-attachments/assets/e58af671-dbce-4a57-9a84-f71d1dc1f0fe" />

- MySQL 에서는 PK 나 FK, UNIQUE 제약 조건을 설정하면 해당 컬럼에 대해 자동으로 인덱스를 생성한다 
- `Non_unique` : 1이면 중복 값을 허용하는 인덱스, 0이면 중복을 허용하지 않는 고유 인덱스
- `Cardinality` : 인덱스에 저장된 유니크한 값의 개수에 대한 추정치. 이 값이 높을수록 중복도가 낮다는 뜻이며 인덱스의 성능이 좋다고 볼 수 있다
```mysql
SHOW INDEX FROM 테이블명;
```
#### 인덱스 삭제
- 사용하지 않거나 쓰기 성능에 방해되는 인덱스는 삭제한다
```mysql
DROP INDEX 인덱스이름 ON 테이블이름;
```

<br>

## 인덱스가 사용되는 상황
> EXPLAIN 을 통해 실제 사용되는 인덱스 확인 ( [참고](https://github.com/dlask913/TIL/blob/main/sql/mysql-optimizer-explain.md) )

### 1. 동등 비교 ( = )
- `type: ref` 는 = 조건이나 JOIN 에서 인덱스를 사용했음을 의미
- 샘플 데이터가 너무 적은 경우 풀테이블 스캔을 선택할 수 있는데 FORCE INDEX 를 사용하여 강제로 인덱스를 사용할 수 있다 ( 권장 X )

### 2. 범위 검색
- `type: range` 는 특정 범위의 데이터를 스캔하는 BETWEEN, >, <, LIKE 등에서 사용했음을 의미
- LIKE 절에서는 인덱스를 사용하려면 와일드카드(%)가 검색어의 뒤에 위치해야 한다 ( `검색어%` )
- LIKE 절에서 `%검색어%` 의 경우 데이터가 많아질수록 성능이 심각하게 저하되기 때문에 점누검색 기능을 활용한다 ( `MATCH ... AGAINST` )

### 3. 정렬
- WHERE 조건과 ORDER BY 조건이 인덱스와 일치하면 filesort 를 생략하여 성능이 개선
- 인덱스를 역방향으로 조회하더라도 단일 컬럼 인덱스에서는 filesort 없이 처리 가능 -> 역방향 스캔 ( Backward index scan )
- 단일 컬럼 인덱스인 경우 역방향 스캔과 내림차순 인덱스( Using index condition )의 성능 차이가 크지 않을 수 있다 
- 여러 컬럼에 대해 서로 다른 정렬 순서가 필요한 복잡한 쿼리에서는 내림차순 인덱스가 훨씬 효율적이다

<br>

## 트리자료구조
### 이진탐색트리 
- 데이터 값을 기준으로 정렬해서 보관
- 중위 순회를 통해 빠른 탐색 가능 - O(log n)
### 밸런스 트리
- 이진 탐색 트리는 데이터가 순차적으로 입력되면 한 쪽으로 치우쳐져 최악의 경우 O(n) 이 발생할 수 있는데 이를 해결할 수 있다
- 트리의 균형이 너무 깨진 경우 동적으로 균형을 다시 맞춘다
### 실제 인덱스에 사용되는 트리
- B-Tree 는 밸런스 트리의 일종으로, B-Tree 혹은 B-Tree 의 변형 사용


<br>

## 참고
[김영한의 실전 데이터베이스 - 기본편](https://inf.run/2aFFu)