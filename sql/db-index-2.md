## (sql) 인덱스 2
> 옵티마이저와 인덱스 선택, 커버링 인덱스, 복합 인덱스, 인덱스 생성 핵심 전략

<br>

## 옵티마이저와 인덱스 선택
- 옵티마이저가 인덱스 사용이 비효율적이라 판단하면 full table scan 이 될 수 있다
- 위 손익분기점은, 인덱스를 사용하는 비용 (랜덤 I/O) >= 풀테이블 스캔 비용 (순차 I/O)
- 일반적으로 전체 데이터의 약 20~25% 이상을 조회해야 하는 쿼리는 차라리 full table scan 이 더 효율적이라고 알려져 있다
- 전체 데이터 수가 많이 적은 경우에도 full table scan 을 선택할 가능성이 높다
- 랜덤 I/O 가 순차 I/O 보다 느린 이유는 데이터를 찾는 과정 때문인데 랜덤 I/O 는 책의 여러 페이지를 순서없이 찾아 읽는 것과 같다
```mysql
WHERE price BETWEEN 50000 AND 100000;
  -- → type: range, rows 5, Using index condition : 총 25건 중 5건 반환으로 20% 
WHERE price BETWEEN 1000 AND 200000;
  -- → type: full, rows 25, Using where : 총 25건 중 25건 반환으로 100% 
```

<br>

## 커버링 인덱스
> ※ 인덱스 동작 순서
> 1. 인덱스 스캔 : where 조건에 맞는 데이터(의 위치) 찾기
> 2. 테이블 데이터 접근 : 인덱스를 통해 찾은 위치 정보로 **원본 테이블에 접근**해서 select 절에서 요구하는 다른 컬럼의 데이터를 가져온다

- 원본 테이블에서 데이터를 찾는 과정에서 랜덤 I/O 를 유발하므로 비용이 발생하는데 커버링 인덱스를 통해 이를 해결할 수 있다
- 커버링 인덱스는 쿼리에 필요한 모든 컬럼을 포함하고 있는 인덱스로, 원본 테이블에 전혀 접근하지 않고 오직 인덱스만을 읽어서 쿼리를 처리한다 → `Extra: Using Index`
- where 절에서 동등 비교나 범위 검색에 사용되는 컬럼을 가장 앞에 두어야 인덱스를 효율적으로 사용할 수 있다
#### 장점
- SELECT 성능 향상 : 테이블 접근을 위한 랜덤 I/O를 제거하여 조회 성능 개선
- COUNT 쿼리 최적화 : `COUNT(*)` 조회 시 테이블 전체가 아닌 인덱스만 스캔하여 빠르게 결과 반환 가능
#### 단점
- 저장 공간 증가 : 인덱스는 원본 데이터와 별도로 저장 공간 차지
- 쓰기 성능 저하 : INSERT, UPDATE, DELETE 작업 시, 테이블 데이터뿐 아니라 인덱스도 함께 수정 필요
#### 효율적으로 사용하기 
- 조회가 매우 빈번하고 쓰기 작업은 상대적으로 적은 테이블에 적용
- select 절에서 조회하는 컬럼의 개수가 적을 때 유리
- 성능 저하가 발생하는 특정 쿼리를 튜닝하기 위한 비장의 무기로 사용

<br>

## 복합 인덱스
- 두 개 이상의 컬럼을 묶어서 하나의 인덱스로 만드는 것으로 컬럼의 순서가 매우 중요하다 
- (category, price) 순으로 복합 인덱스를 만들면 ① category 를 기준으로 먼저 정렬하 ② 같은 category 내에서 price 를 기준으로 다시 정렬한다 → price 만으로 검색하면 인덱스 전체를 훑어야하기 때문에 옵티마이저는 full table scan 을 선택할 수 있다 
- 인덱스 생성 시 **앞에 있는 컬럼을 기준으로 정렬된 상태에서만 제 역할이 가능**

### 복합 인덱스 생성 원칙 
 1. 인덱스는 순서대로 사용하기 ( 왼쪽 접두어 규칙 )
 2. 등호 조건을 사용하는 컬럼을 앞에, 범위 조건을 사용하는 컬럼을 뒤에 두는 것으로 설계
 3. 정렬( order by )도 인덱스 순서를 따라서 순서 배치
 4. 인덱스를 많이 생성하기보단 기존 인덱스를 활용한다 

### IN 절 활용하기 
- 범위 검색해야하는 컬럼이 인덱스 앞에 있을 때는 IN 절을 활용한다 
- IN 절은 여러개의 동등 비교묶음으로 인식하기 때문에 범위가 한정적인 컬럼에 사용하면 좋다 
- IN 절에 들어가는 값이 수백, 수천 개로 너무 많아지면 성능이 저하될 수 있기 때문에 EXPLAIN 을 통해 항시 확인

<br>

## 인덱스 생성 핵심 전략

> ※ 실무 가이드
> - 명확한 목적없이 인덱스 생성하지 않기
> - 사용하지않는 인덱스 주기적으로 삭제 
> - 인덱스 컬럼을 가공하면 인덱스 적용이 안되기때문에 가공 X

### 카디널리티
- 해당 컬럼에 저장도니 값들의 고유성 정도를 나타내는 지표
- 높다 : 중복되는 값이 거의 없음을 의미 / 낮다 : 중복되는 것이 많음을 의미
- 인덱스는 카디널리티가 높은, 즉 식별력이 좋은 컬럼에 생성할 때 가장 효율적이다

### 생성 가이드라인
#### 1. WHERE 절에 자주 사용되는 컬럼
#### 2. JOIN 의 연결고리가 되는 컬럼 (FK) 
- 외래키에 인덱스가 없으면 데이터베이스는 ex>seller_id=1 인 데이터를 처음부터 끝까지 스캔을 각 행마다 반복
- JOIN 에 사용되는 외래키 컬럼에는 반드시 인덱스를 생성해야 한다
- MySQL 은 외래키 제약조건을 설정하면 인덱스를 자동 생성한다 
#### 3. ORDER BY 절에서 자주 사용되는 컬럼
- 데이터의 양이 많을 경우 filesort 는 결과를 반환하기 전 모든 데이터를 메모리에 올리고 정렬해야하기 때문에 매우 비용이 큰 작업이다

### 단점과 주의사항
#### 저장 공간 ( Storage )
- 인덱스는 일반적으로 원본 테이블 크기의 약 10% 공간을 추가로 차지 → 디스크 사용량 증가
#### 쓰기 성능 ( INSERT, UPDATE, DELETE )
- 데이터에 변경이 생길때마다 원본 테이블 뿐 아니라 이와 관련된 모든 인덱스를 함꼐 수정해야 한다 → INSERT, UPDATE, DELETE 속도 저하

<br>

## 참고
[김영한의 실전 데이터베이스 - 기본편](https://inf.run/2aFFu)