# 카프카 스트림즈
> 카프카 스트림즈, Streams DSL 에서의 KStream, KTable, GlobalKTable

<br>

## 카프카 스트림즈
- 토픽에 적재된 데이터를 실시간으로 변환하여 다른 토픽에 적재하는 라이브러리로 클러스터와 통신하여 스트리밍 데이터를 처리한다. 
- 카프카에서 공식적으로 지원하는 라이브러리로, 카프카 버전이 오를 때마다 같이 릴리즈되기 때문에 카프카 클러스터와 완벽하게 호환되면서 스트림 처리에 필요한 편리한 기능들을 제공한다. 
- 스트림즈 애플리케이션 또는 카프카 브로커에 장애가 발생해도 **정확히 한 번(exactly once) 할 수 있도록 장애 허용 시스템(fault tolerant system)**을 가지고 있어 데이터 처리 안정성이 매우 뛰어나다.
- 카프카 클러스터를 운영하면서 실시간 스트림 처리를 해야하는 필요성이 있다면 카프카 스트림즈 애플리케이션으로 개발하는 것이 가장 좋다.
### 사용해야 하는 이유
- 스트림 데이터 처리에 있어 필요한 다양한 기능을 스트림즈DSL(★)로 제공하며 필요하다면 프로세서 API(★) 를 사용하여 기능을 확장할 수 있다. 
- 스트림즈 라이브러리의 단 한 번의 데이터 처리, 장애 허용 시스템 등의 특징들은 컨슈머와 프로듀서의 조합만으로는 완벽하게 구현하기는 어렵다. 
- 소스 토픽(사용하는 토픽)과 싱크 토픽(저장하는 토픽)이 서로 다른 클러스터에 있는 경우 컨슈머와 프로듀서를 직접 조합하여 개발할 수 있다.
### 스트림즈 내부 구조
- 스트림즈 애플리케이션은 내부적으로 스레드를 1개 이상 생성할 수 있으며, 스레드는 1개 이상의 태스크를 가진다.  **태스크(task)** 는 스트림즈 애플리케이션을 실행하면 생기는 데이처리 최소 단위를 말한다. 
- 만약 3개의 파티션으로 이루어진 토픽을 처리하는 스트림즈 애플리케이션을 실행하면 내부에 3개의 태스크가 생긴다.
- 컨슈머 스레드를 늘리는 방법과 동일하게 병렬처리를 위해 파티션과 스트림즈 스레드(또는 프로세스) 개수를 늘림으로써 처리량을 늘릴 수 있다. 

> ※ 스트림즈 애플리케이션 스케일 아웃 <br>
> : 실제 운영환경에서는 장애가 발생하더라도 안정적으로 운영할 수 있게 **2개 이상의 서버**로 구성하여 스트림즈 애플리케이션을 운영한다.

<br>

### 토폴로지, 프로세서와 스트림
- 토폴로지 : 2개 이상의 노드들과 선으로 이루어진 집합
- 토폴로지 종류 : 링형, 트리형, 성형(start) 등 → 스트림즈에서 사용하는 토폴로지는 트리 형태와 유사하다.
- 프로세서(processor) : 카프카 스트림즈에서 토폴로지를 이루는 노드
- 스트림(stream) : 노드와 노드 사이를 이은 선으로, 토픽의 데이터를 뜻하는데 프로듀서와 컨슈머에서의 레코드와 동일하다. 

### 프로세서의 종류
1. 소스 프로세스 : 데이터를 처리하기 위해 최초로 선언해야 하는 노드로, 하나 이상의 토픽에서 데이터를 가져오는 역할을 한다. 
2. 스트림 프로세서 : 다른 프로세서가 반환한 데이터를 변환, 분기처리와 같은 로직 등 처리하는 역할을 한다. 
3. 싱크 프로세서 : 데이터를 특정 카프카 토픽으로 저장하는 역할을 하며 스트림즈로 처리된 데이터의 최종 종착지이다. 

<br>


## 스트림즈 DSL

### 스트림즈DSL 과 프로세서API
: 스트림즈DSL 은 스트림 프로세싱에 쓰일만한 다양한 기능들을 자체 API 로 만들어 놓았기 때문에 대부분 변환 로직을 개발할 수 있으며, 제공하지 않는 일부 기능들의 경우 프로세서 API 를 사용하여 구현할 수 있다. 
#### 1. 스트림즈DLS 로 구현하는 데이터 처리 예시 
- 메시지 값을 기반으로 토픽 분기 처리
- 지난 10분간 들어온 데이터의 개수 집계
#### 2. 프로세서API 로 구현하는 데이터 처리 예시
- 메시지 값의 종류에 따라 토픽을 가변적으로 전송
- 일정한 시간 간격으로 데이터 처리

<br>

### 스트림즈 DSL 에서의 데이터 처리 개념
#### KStream
- 레코드의 흐름을 나타내며, 각각의 레코드는 메시지 키와 메시지 값으로 구성되어 있다. 
- KStream 데이터를 조회하면 토픽에 존재하는 모든 레코드가 출력된다.
#### KTable
- 메시지 키를 기준으로 데이터를 관리하고, 동일한 메시지 키에 대해 새로운 데이터가 들어오면 이전 데이터를 업데이트하는 방식으로 동작한다.
- 데이터를 조회할 때 유니크한 메시지 키에 해당하는 가장 최신의 레코드만 출력된다.
#### 코파티셔닝
- KStream 과 KTable 을 조인하려면 반드시 코파티셔닝(co-partitioning)되어 있어야 한다.
- 코파티셔닝이란 조인을 하는 **두 데이터 소스(ex> KStream과 KTable)의 파티션 개수가 동일하고 파티셔닝 전략을 동일**하게 맞추는 작업이다. → 동일한 메시지 키를 가진 데이터가 동일한 태스크에 들어가는 것을 보장
- 코파티셔닝이 되지 않으면 `TopologyException` 이 발생한다. 
#### GlobalKTable
- 코파티셔닝되지 않은 KStream 과 KTable 을 조인해서 사용하고 싶을 때 KTable 을 GlobalKTable 로 선언하여 사용할 수 있다. 
- KTable 과 달리 GlobalKTable 로 정의된 데이터는 스트림즈 애플리케이션의 모든 태스크에 동일하게 공유되어 사용된다. 
- GlobalKTable 은 모든 태스크에서 데이터를 복제하기 때문에 큰 용량의 데이터를 처리할 때는 부담이 될 수 있다. 


<br>

## 참고
[아파치 카프카 애플리케이션 프로그래밍](https://inf.run/uCwV5) <br>
https://docs.confluent.io/platform/current/streams/concepts.html#kstream