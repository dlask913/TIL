# 카프카 컨슈머와 컨슈머 그룹
> 컨슈머, 컨슈머 그룹, 리밸런싱, 커밋, 어사이너

<br>

## 컨슈머
- 브로커에 적재된 프로듀서가 전송한 데이터를 사용하기 위해 브로커로부터 데이터를 가져온다.
### 내부 구조
> 카프카 클러스터 → Fetcher → poll() → ConsumerRecords
- Fetcher : 리더 파티션으로부터 레코드들을 미리 가져와서 대기.
- poll() : Fetcher 에 있는 레코드들을 ConsumerRecords 객체로 반환한다. 
- ConsumerRecords : Consumer가 처리할 메시지들의 집합으로, 오프셋 정보도 포함되어 있다.
- commit : 성공적으로 처리한 후, 해당 메시지의 오프셋을 카프카에 저장한다. 

<br>

## 컨슈머 그룹
- 컨슈머들의 집합으로, 각기 다른 컨슈머들로부터 서로 독립적으로 메시지를 처리할 수 있게 하며 격리된 환경에서 안전하게 운영할 수 있도록 한다. 
- 그룹으로 묶인 컨슈머들은 토픽의 1개 이상 파티션들에 할당되어 데이터를 가져갈 수 있는데 1개의 파티션은 최대 1개의 컨슈머에 할당 가능하고 1개의 컨슈머는 여러 개의 파티션에 할당될 수 있다. → 즉, 컨슈머 그룹의 컨슈머 개수는 토픽의 파티션 개수보다 같거나 작아야 한다. 
- 일반적으로 토픽의 개수와 컨슈머의 개수를 동일하게 설정한다. 

### 컨슈머 그룹의 컨슈머가 파티션 개수보다 많을 경우
- 4개의 컨슈머로 이루어진 컨슈머 그룹이 3개의 파티션을 가진 토픽에서 데이터를 가져간다면 1개의 컨슈머는 파티션을 할당받지 못하고 유휴 상태로 남게 된다. 
- 파티션을 할당받지 못한 컨슈머는 스레드만 차지하고 데이터 처리를 못하므로 불필요한 스레드로 남게 된다. 

### 컨슈머 그룹을 활용하는 이유 
: 서로 다른 컨슈머 그룹은 같은 토픽을 구독하더라도 독립적으로 오프셋을 관리하므로 여러 애플리케이션이 같은 데이터를 독립적으로 처리할 수 있다. <br>
<br>
예를 들어, 하나의 컨슈머 그룹은 실시간 분석을 위해 데이터를 처리하고 다른 컨슈머 그룹은 데이터를 저장용으로 처리하여 특정 애플리케이션이 장애가 발생하더라도 다른 애플리케이션이 데이터를 적재하는 것에 영향이 없도록 한다. 

<br>

## 리밸런싱
- 컨슈머 그룹으로 이루어진 컨슈머들 중 일부 컨슈머에 장애가 발생하면, 파티션의 소유권이 장애가 발생하지 않은 컨슈머로 넘어가는 것을 말한다. 
- 리밸런싱은 크게 두 가지 상황에서 일어나는데, 첫 번째는 컨슈머가 추가되는 상황이고 두 번째는 컨슈머가 제외되는 상황이다.
- 이슈가 발생한 컨슈머를 컨슈머 그룹에서 제외하여 모든 파티션이 지속적으로 데이터를 처리할 수 있도록 가용성을 옾여준다. 
- 토픽의 개수가 많을수록 리밸런싱 시간이 길어질 수 있기 때문에, 데이터 처리 중 발생한 리밸런싱에 대응하는 코드를 작성해야 한다. 

<br>

## 커밋
- 컨슈머는 카프카 브로커로부터 데이터를 어디까지 가져갔는지 커밋을 통해 기록한다. 
- 특정 토픽의 파티션을 어떤 컨슈머 그룹이 몇 번째 가져갔는지 카프카 브로커 내부에서 사용되는 내부 토픽 ( consumer_offsets ) 에 기록된다. 
- 컨슈머 동작 이슈가 발생하여 consumer_offsets 토픽에 어느 레코드까지 읽어갔는지 오프셋 커밋이 기록되지 못했다면 데이터 처리의 중복이 발생할 수 있기 때문에 **컨슈머 애플리케이션이 오프셋 커밋을 정상적으로 처리했는지 검증**해야만 한다.

<br>

## 어사이너 ( Assignor )
- 컨슈머와 파티션 할당 정책은 컨슈머의 Assignor 에 의해 결정되며 카프카에서는 RangeAssignor, RoundRobinAssignor, StickyAssignor 를 제공한다. 
- 카프카 2.5.0 은 RangeAssignor 가 기본값으로 설정된다. ( 3.0 부터는 CooperativeStickyAssignor )
- 파티션과 컨슈머를 일대일 매핑 하게되면 크게 신경쓰지 않아도 된다. 
1. RangeAssignor : 각 토픽에서 파티션은 숫자로 정렬, 컨슈머는 사전 순서로 정렬하여 할당한다.
2. RoundRobinAssignor : 모든 파티션을 컨슈머에서 번갈아가면서 할당한다.
3. StickyAssignor : 최대한 파티션을 균등하게 배분하면서 할당한다. 

<br>

## 참고
[아파치 카프카 애플리케이션 프로그래밍](https://inf.run/uCwV5) <br>
https://cwiki.apache.org/confluence/display/KAFKA/KIP-429%3A+Kafka+Consumer+Incremental+Rebalance+Protocol 