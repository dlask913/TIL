# (kafka) 기본 구조 및 데이터 파이프라인에 적합한 이유
> Kafka 기본 구조 및 데이터 파이프라인에 적합한 이유 4가지

<br>

## 아파치 카프카의 탄생
소스 애플리케이션과 타깃 애플리케이션이 늘어남에 따라 타깃 애플리케이션이 문제가 생겼을 때 여러 소스 애플리케이션이 장애가 발생함을 해결하기 위하여 링크드인에서 다양한 메시지 플랫폼과 ETL 툴을 적용하여 아키텍처를 변경하려고 노력했지만 힘들었고 결국, 신규 시스템인 아파치 카프카를 만들었다. 

카프카는 각각의 애플리케이션끼리 연결하여 데이터를 처리하는 것이 아니라 한 곳에 모아 처리할 수 있도록 **중앙집중화** 하였다. 

<br>

## 카프카 기본 구조 
![image](https://github.com/dlask913/TIL/assets/79985588/5ee4ca8d-5f61-4447-b0f4-4dabb3abad7c)

- **Topic** : RDBS 의 Table 과 같은 개념으로 특징을 나타내는 데이터가 들어있다. 1개 이상의 Partition 을 가진다.
- **Partition** : 큐 구조(FIFO) 와 동일하다.
- **Producer** : 특정 메시지(데이터) 를 보내고 이 메시지는 토픽 내 여러 파티션 중 1개의 파티션에 적재된다.
- **Consumer** : 구독을 함으로서 파티션에 적재되어있는 데이터를 가져간다. ( 데이터는 삭제되지 않는다. )

<br>

## 카프카가 데이터 파이프라인으로 적합한 4가지 이유
카프카는 여러 용도가 있지만 데이터 파이프라인으로 가장 많이 쓰인다. 
### 1. 높은 처리량
: 많은 양의 데이터를 송수신할 때 맺어지는 네트워크 비용은 무시할 수 없는 규모가 되는데, 카프카에서는 많은 양의 데이터를 묶음 단위로 처리하는 배치를 옵션으로 제공한다. 또한, Partition 단위를 통해 동일 목적의 데이터를 여러 파티션에 분배하고 데이터를 병렬 처리할 수 있고 파티션 개수만큼 컨슈머 개수를 늘려 처리량을 늘릴 수 있다.
### 2. 확장성
: 데이터를 모을 때 데이터가 얼마나 들어올 지 예측하기가 힘든데, 카프카는 가변적인 환경에서 안정적으로 확장 가능하도록 설계되어있다. 클러스터 내 브로커는 처리량에 한계가 있는데 브로커의 개수를 늘려 확장이 가능하다. -> Scale-Out
### 3. 영속성
: 영속성이란 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성을 뜻한다. 카프카는 메모리가 아닌 파일 시스템에 데이터를 저장한다. 페이지 캐시 메모리 영역을 사용해서 한 번 읽은 파일 내용을 메모리에 저장시켰다가 다시 사용하기 때문에 파일 시스템에 데이터를 저장하더라도 데이터 처리량이 높다. 그래서 브로커에 장애가 발생하여도 파일 시스템에 데이터를 저장하기 때문에 안전하다.
### 4. 고가용성
: 3개 이상의 서버들로 운영되는 카프카 클러스터는 일부 서버에 장애가 발생하더라도 무중단으로 안전하고 지속적으로 데이터를 처리할 수 있다. 카프카 클러스터는 보통 브로커라고 불리는 프로세서를 3개 이상 실행시켜서 운영하게 된다. 프로듀서에서 데이터를 보냈을 때 메시지는 한 개의 브로커에만 저장되는 게 아니라 복제가 되서 다른 브로커들에도 저장이 되게 된다. 그래서 특정 브로커에 장애가 발생하여도 다른 브로커에 적재된 데이터를 지속적으로 가져감으로써 프로듀서가 데이터를 보내고 컨슈머가 데이터를 받는 것이 계속 가능하다. 

<br>

## 참고
[아파치 카프카 애플리케이션 프로그래밍](https://inf.run/uCwV5)